#
# DAO part of the lib-pyplagia.
# pyplagia, Pierre-Antoine BRAMERET (C) 2014


# !! Pickling should not be done by DAO, because DAO deals with data, not with code.
#  So Pickling should be moved to LibPlagia, with a METHODS_PICKLING
#  and another function/something, outside of both DAO and LibPlagia, should do the
#   "precaching" which is to LibPlagia.pickle unpickled homeworks and record picks to DAO
# Now, where does the lTokens should go? DAO? LibPlagia? something else?
#  They are generated by LibPlagia, retrieved from DB by DAO, used by LibPlagia (in getScore())
# So LibPlagia.readPickleCache(dao)





import sqlite3
from . import pickle
from . import time

from . import LibPlagia



#-------------------------------------------------------------------------------
# DAO
#-------------------------------------------------------------------------------

# DAO is unique, uses a string to identify the results which are to be dumped or load
#  so access should be grouped, and lists in argument should a serious length (100, 1000 ?)
class DAO:
    # Sim A: with 0 for any kind of mismatch
    # Sim B: with -2 for mismatch between non-identifiers
    getTableNameCmp  = lambda sMethod:   'Cmp{}'.format(sMethod)
    getTableNamePick = lambda sMethPick: 'Pickle{}'.format(sMethPick)
    
    def __init__(self, sDB, timeout=5):
        self.sDB = sDB
        self.db = sqlite3.connect(self.sDB, timeout)
        with self.db as db:
            # Stores the {x}ToToken which are the customized token infos for the different methods taking into account identifiers. Should be unique and project-wide...
            db.execute('CREATE TABLE IF NOT EXISTS PickleDicTokenToInt (name TEXT NOT NULL PRIMARY KEY, data BLOB NOT NULL)') # Name is nameToToken or nodeToToken
            #db.execute('CREATE TABLE IF NOT EXISTS Pickles (sFile TEXT PRIMARY KEY, bPick BLOB NOT NULL)')
            for sMeth in LibPlagia.METHODS:
                db.execute('''CREATE TABLE IF NOT EXISTS {} (sFileA TEXT NOT NULL, sFileB TEXT NOT NULL, fScore REAL,
                           PRIMARY KEY (sFileA, sFileB))'''.format(DAO.getTableNameCmp(sMeth)))
            for sMethPick in LibPlagia.METHODS_PICKLING:
                db.execute('''CREATE TABLE IF NOT EXISTS {} (sFile TEXT NOT NULL PRIMARY KEY,
                           data BLOB NOT NULL)'''.format(DAO.getTableNamePick(sMethPick)))

##    def getNameToToken(self):
##        '''Name to token is not thread-safe : all tokens should be precomputed in a single thread!'''
##        dic = self.db.execute('SELECT * FROM PickleNameToToken').fetchone()
##        return pickle.loads(dic[0]) if dic else initNameToToken()
##    def setNameToToken(self, nameToToken):
##        '''Name to token is not thread-safe : all tokens should be precomputed in a single thread!'''
##        with self.db as db:
##            db.execute('DELETE FROM PickleNameToToken')
##            db.execute('INSERT INTO PickleNameToToken VALUES(?)', (pickle.dumps(nameToToken),))
    def getDicTokenToInt(self, sName):
        '''Name to token is not thread-safe : all tokens should be precomputed in a single thread!'''
        dic = self.db.execute('SELECT data FROM PickleDicTokenToInt WHERE name=?', (sName,)).fetchone()
        return pickle.loads(dic[0]) if dic else initNameToToken()
    def setDicTokenToInt(self, sName, dTokenToInt):
        '''Name to token is not thread-safe : all tokens should be precomputed in a single thread!'''
        with self.db as db:
            db.execute('INSERT OR REPLACE INTO PickleDicTokenToInt VALUES(?,?)', (sName, pickle.dumps(dTokenToInt)))
    def getDictsTokenToInt(self):
        '''Name to token is not thread-safe : all tokens should be precomputed in a single thread!'''
        dDictsTok = {}
        for sName,bDic in self.db.execute('SELECT * FROM PickleDicTokenToInt'):
            assert sName in LibPlagia.METHODS_PICKLING
            dDictsTok[sName] = pickle.loads(bDic)
        return dDictsTok
    def setDictsTokenToInt(self, ddTokenToInt):
        '''Name to token is not thread-safe : all tokens should be precomputed in a single thread!'''
        for sName in ddTokenToInt:
            assert sName in LibPlagia.METHODS_PICKLING
        with self.db as db:
            for sName in ddTokenToInt:
                db.execute('INSERT OR REPLACE INTO PickleDicTokenToInt VALUES(?,?)', (sName, pickle.dumps(ddTokenToInt[sName])))

    # With proper thinking, this one might not be performant:
    #  there are not so many files, they should be returned in a dict form (with too much keys, but not that much)
    #  and when they are to be pickled, the function should not return anything, so...
##    def getTokensFileList(self, lFiles, bPreserveNameToToken=True):
##        '''Name to token is not thread-safe : all tokens should be precomputed in a single thread!'''
##        # Note to self: yes, avoided repeated tokenization is good, but ... is tokenization so much time-consuming?
##        # Note to self: as sqlite&Lock show crazy race conditions, it is finally a rather bad idea to store tokenized info ... because the get() is now the bottleneck... (!!!)
##        with self.db as db: # Locks (hopefully) the DB, so this should avoid race conditions
##            lPickle = []
##            for sFile in lFiles:
##                tPick = self.db.execute('SELECT bPick FROM Pickles WHERE sFile=?', (sFile,)).fetchone()
##                if tPick:
##                    bPick, = tPick
##                    lPickle.append(pickle.loads(bPick))
##                else:
##                    if bPreserveNameToToken:
##                        raise ValueError('File was not pre-tokenized')
##                    with open(sFile, 'rb') as f:
##                        lTok = intifyTokens(list(tokenize.tokenize(f.readline)))
##                    with self.db as db:
##                        db.execute('INSERT INTO Pickles VALUES(?,?)', (sFile, pickle.dumps(lTok)))
##            return lPickle
 #
##    def getTokensDict(self):
##        dTokens = {}
##        with self.db as db:
##            for sFile,bPick in db.execute('SELECT * FROM Pickles'):
##                dTokens[sFile] = pickle.loads(bPick)
##        return dTokens
##    def getListOfTokenizedFiles(self):
##        return [f for f, in self.db.execute('SELECT sFile FROM Pickles')]
##    def genPickleForFiles(self, lFiles, bForce=False):
##        with self.db as db:
##            lFilesDone = self.getListOfTokenizedFiles()
##            for sFile in lFiles:
##                if bForce or not sFile in lFilesDone:
##                    with open(sFile, 'rb') as f:
##                        lTok = intifyTokens(list(tokenize.tokenize(f.readline)))
##                    db.execute('INSERT OR REPLACE INTO Pickles VALUES(?,?)', (sFile, pickle.dumps(lTok)))

    def setPickleForFiles(self, sMethPick, lCpl):
        'lCpl = [(sFile, bData), ...]'
        assert sMethPick in LibPlagia.METHODS_PICKLING
        for sFile,bData in lCpl:
            iSuf = sFile.find('/20')+1
            assert (iSuf and sFile[iSuf:iSuf+4].isdecimal() and
                   int(sFile[iSuf:iSuf+4])<=time.localtime().tm_year and 2011<=int(sFile[iSuf:iSuf+4]) and 
                   sFile[iSuf+4]=='_'), \
                   'It is mandatory that the filenames begin with the year (between 2011 and now) followed by an underscore ({}_) instead of "{}"'.format(time.localtime().tm_year, sFile)
        with self.db as db:
            db.executemany('INSERT OR REPLACE INTO {} VALUES(?,?)'.format(DAO.getTableNamePick(sMethPick)), lCpl)
    def getIntifiedFiles(self): # getCache()
        # Dirty... -> class Cache
        ddMethFileInts = {} # {'Sim': {'eleve.py':[12,43,...], ...}, ...}
        with self.db as db:
            for sMethPick in LibPlagia.METHODS_PICKLING:
                dInts = {}
                for sFile,bPick in db.execute('SELECT * FROM {}'.format(DAO.getTableNamePick(sMethPick))):
                    dInts[sFile] = pickle.loads(bPick)
                ddMethFileInts[sMethPick] = dInts
        return ddMethFileInts


    def getCmpListIter(self, sMeth):
        assert sMeth in LibPlagia.METHODS
        return self.db.execute('SELECT * FROM {}'.format(DAO.getTableNameCmp(sMeth)))
    def getCmp(self, sMeth, sFileA, sFileB):
        assert sMeth in LibPlagia.METHODS
        r = self.db.execute('SELECT * FROM {} WHERE sFileA=? AND sFileB=?'.format(DAO.getTableNameCmp(sMeth)), (sFileA, sFileB)).fetchone()
        return r[0] if r else None
    def setCmpList(self, sMeth, lTriples):
        """lTriples: [(sFileA, sFileB, fScore), ...]"""
        assert sMeth in LibPlagia.METHODS
        for tup in lTriples:
            assert len(tup) == 3 # Might be superfluous, but might help when debugging
        sCmd = 'INSERT OR REPLACE INTO {} VALUES(?,?,?)'.format(DAO.getTableNameCmp(sMeth))
        with self.db as db:
            db.executemany(sCmd, lTriples)


    #----------------------------------
    # Preparing to-do lists
    #----------------------------------
    def prepareToDoList(self, bForceRecalc):
        ddMethFileInts = self.getIntifiedFiles()
        lToDo = []
        for sMeth in LibPlagia.METHODS:
            sMethPick = LibPlagia.METHODStoMETHODS_PICKLING[sMeth]
            dFileInts = ddMethFileInts[sMethPick]
            #lCmpList = self.getCmpList(sMeth) # [(sFileA, sFileB, fSc), ...]
            sCmpList = {(sA,sB) for sA,sB,sc in self.getCmpListIter(sMeth)} # More usable, more efficient
            for sFileA in dFileInts:
                for sFileB in dFileInts:
                    if sFileB == sFileA:
                        continue
                    if bForceRecalc or not (sFileA, sFileB) in sCmpList:
                        lToDo.append( (sMeth, sFileA, sFileB) )
        return lToDo
        
    def prepareToDoList_yearBelow(self, bForceRecalc, iYear):
        'Only take files from year iYear on left-hand and from year iYear and below on right-hand'
        lToDoFull = self.prepareToDoList(bForceRecalc)
        lToDo = []
        for sMeth,sFileA,sFileB in lToDoFull:
            iSufA = sFileA.find('/20')+1
            iSufB = sFileB.find('/20')+1
            if int(sFileA[iSufA:iSufA+4]) != iYear:
                continue
            if int(sFileB[iSufB:iSufB+4]) > iYear:
                continue
            lToDo.append( (sMeth,sFileA,sFileB) )
        return lToDo



    #----------------------------------
    # Displaying results
    #----------------------------------
    def getTopPlagia(self, nTop=10):
        'Returns a {sMeth:[(sFileA, sFileB, fSc), ... nTop times]} sorted by fSc, decreasing order'
        dTop = {}#{sMeth:[] for sMeth in LibPlagia.METHODS}
        for sMeth in LibPlagia.METHODS:
            lTop = list(self.getCmpListIter(sMeth))
            lTop.sort(key=lambda t:-t[2])
            dTop[sMeth] = lTop[:nTop]
        return dTop

    def displayTopPlagia(self, nTop=10):
        dTop = self.getTopPlagia(nTop)
        for sMeth in LibPlagia.METHODS:
            print('---------------------------------------------------------')
            print('  Method {}'.format(sMeth))
            for sFileB,sFileA,fSc in dTop[sMeth]: # FIXME: for ilar and sim, the second file is the pattern, so the one which is the excerpt of the other is the second one. Maybe not for future methods. Watch out !
                iSufA = sFileA.find('/20')+6
                iSufB = sFileB.find('/20')+6
                sYA = sFileA[iSufA-5:iSufA-1]
                sYB = sFileB[iSufB-5:iSufB-1]
                print('{:.3f} {} {} ## copie sur ## {}'.format(fSc, (sYA!=sYB) and '#' or ' ', sFileB[iSufA-3:], sFileA[iSufB-3:]))

    def getRepartition(self, sMeth, nSegments=100):
        'Returns the repartition of the cmp results for the given method, as a bar graph'
        assert sMeth in LibPlagia.METHODS
        lnOccur = [0]*nSegments
        #nSegments /= 2
        for sFileA,sFileB,fSc in self.getCmpListIter(sMeth):
            if fSc == 1.:
                lnOccur[-1] += 1
            elif fSc < 0:
                continue
            else:
                lnOccur[int(fSc*nSegments)] += 1
        return lnOccur
        
            
        









